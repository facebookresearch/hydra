"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8196],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var a=t(96540);const i={},s=a.createContext(i);function o(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:n},e.children)}},44423:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"advanced/instantiate_objects/overview","title":"Instantiating objects with Hydra","description":"One of the best ways to drive different behavior in an application is to instantiate different implementations of an interface.","source":"@site/docs/advanced/instantiate_objects/overview.md","sourceDirName":"advanced/instantiate_objects","slug":"/advanced/instantiate_objects/overview","permalink":"/docs/advanced/instantiate_objects/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/facebookresearch/hydra/edit/main/website/docs/advanced/instantiate_objects/overview.md","tags":[],"version":"current","lastUpdatedBy":"Ryan Soklaski","lastUpdatedAt":1761323009000,"frontMatter":{"id":"overview","title":"Instantiating objects with Hydra","sidebar_label":"Overview"},"sidebar":"docs","previous":{"title":"Packages","permalink":"/docs/advanced/overriding_packages"},"next":{"title":"Config files example","permalink":"/docs/advanced/instantiate_objects/config_files"}}');var i=t(74848),s=t(28453),o=t(49595);const r={id:"overview",title:"Instantiating objects with Hydra",sidebar_label:"Overview"},l=void 0,c={},d=[{value:"Simple usage",id:"simple-usage",level:3},{value:"Recursive instantiation",id:"recursive-instantiation",level:3},{value:"Disable recursive instantiation",id:"disable-recursive-instantiation",level:3},{value:"Parameter conversion strategies",id:"parameter-conversion-strategies",level:3},{value:"Partial Instantiation",id:"partial-instantiation",level:3},{value:"Instantiation of builtins",id:"instantiation-of-builtins",level:3},{value:"Dotpath lookup machinery",id:"dotpath-lookup-machinery",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:t,GithubLink:a}=n;return t||m("Details",!0),a||m("GithubLink",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(o.C,{text:"Example applications",to:"examples/instantiate"}),"\n",(0,i.jsx)(n.p,{children:"One of the best ways to drive different behavior in an application is to instantiate different implementations of an interface.\nThe code using the instantiated object only knows the interface which remains constant, but the behavior\nis determined by the actual object instance."}),"\n",(0,i.jsxs)(n.p,{children:["Hydra provides ",(0,i.jsx)(n.code,{children:"hydra.utils.instantiate()"})," (and its alias ",(0,i.jsx)(n.code,{children:"hydra.utils.call()"}),") for instantiating objects and calling functions. Prefer ",(0,i.jsx)(n.code,{children:"instantiate"})," for creating objects and ",(0,i.jsx)(n.code,{children:"call"})," for invoking functions."]}),"\n",(0,i.jsx)(n.p,{children:"Call/instantiate supports:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Constructing an object by calling the ",(0,i.jsx)(n.code,{children:"__init__"})," method"]}),"\n",(0,i.jsx)(n.li,{children:"Calling functions, static functions, class methods and other callable global objects"}),"\n"]}),"\n",(0,i.jsxs)(n.admonition,{type:"warning",children:[(0,i.jsx)(n.p,{children:"This may pose a security risk since the config can be used to execute arbitrary code. Make\nsure to use this only with trusted configs."}),(0,i.jsxs)(n.p,{children:["There is a default list of blocklisted modules. To bypass it, set the env var\nHYDRA_INSTANTIATE_ALLOWLIST_OVERRIDE with a colon-separated list of modules to allowlist,\neg. ",(0,i.jsx)(n.code,{children:"HYDRA_INSTANTIATE_ALLOWLIST_OVERRIDE=os.rename:shutil.move"})]})]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Instantiate API (Expand for details)"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def instantiate(config: Any, *args: Any, **kwargs: Any) -> Any:\n    """\n    :param config: An config object describing what to call and what params to use.\n                   In addition to the parameters, the config must contain:\n                   _target_ : target class or callable name (str)\n                   And may contain:\n                   _args_: List-like of positional arguments to pass to the target\n                   _recursive_: Construct nested objects as well (bool).\n                                True by default.\n                                may be overridden via a _recursive_ key in\n                                the kwargs\n                   _convert_: Conversion strategy\n                        none    : Passed objects are DictConfig and ListConfig, default\n                        partial : Passed objects are converted to dict and list, with\n                                  the exception of Structured Configs (and their fields).\n                        object  : Passed objects are converted to dict and list.\n                                  Structured Configs are converted to instances of the\n                                  backing dataclass / attr class.\n                        all     : Passed objects are dicts, lists and primitives without\n                                  a trace of OmegaConf containers. Structured configs\n                                  are converted to dicts / lists too.\n                   _partial_: If True, return functools.partial wrapped method or object\n                              False by default. Configure per target.\n    :param args: Optional positional parameters pass-through\n    :param kwargs: Optional named parameters to override\n                   parameters in the config object. Parameters not present\n                   in the config objects are being passed as is to the target.\n                   IMPORTANT: dataclasses instances in kwargs are interpreted as config\n                              and cannot be used as passthrough\n    :return: if _target_ is a class name: the instantiated object\n             if _target_ is a callable: the return value of the call\n    """\n\n# Alias for instantiate\ncall = instantiate\n'})})]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.p,{children:["The config passed to these functions must have a key called ",(0,i.jsx)(n.code,{children:"_target_"}),", with the value of a fully qualified class name, class method, static method or callable.\nFor convenience, ",(0,i.jsx)(n.code,{children:"None"})," config results in a ",(0,i.jsx)(n.code,{children:"None"})," object."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Named arguments"})," : Config fields (except reserved fields like ",(0,i.jsx)(n.code,{children:"_target_"}),") are passed as named arguments to the target.\nNamed arguments in the config can be overridden by passing named argument with the same name in the ",(0,i.jsx)(n.code,{children:"instantiate()"})," call-site."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Positional arguments"})," : The config may contain a ",(0,i.jsx)(n.code,{children:"_args_"})," field representing positional arguments to pass to the target.\nThe positional arguments can be overridden together by passing positional arguments in the ",(0,i.jsx)(n.code,{children:"instantiate()"})," call-site."]}),"\n",(0,i.jsx)(n.h3,{id:"simple-usage",children:"Simple usage"}),"\n",(0,i.jsx)(n.p,{children:"Your application might have an Optimizer class:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Example class"',children:"class Optimizer:\n    algo: str\n    lr: float\n\n    def __init__(self, algo: str, lr: float) -> None:\n        self.algo = algo\n        self.lr = lr\n"})}),"\n",(0,i.jsxs)("div",{className:"row",children:[(0,i.jsx)("div",{className:"col col--6",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",metastring:'title="Config"',children:"optimizer:\n  _target_: my_app.Optimizer\n  algo: SGD\n  lr: 0.01\n\n\n\n\n"})})}),(0,i.jsx)("div",{className:"col col--6",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Instantiation"',children:"opt = instantiate(cfg.optimizer)\nprint(opt)\n# Optimizer(algo=SGD,lr=0.01)\n\n# override parameters on the call-site\nopt = instantiate(cfg.optimizer, lr=0.2)\nprint(opt)\n# Optimizer(algo=SGD,lr=0.2)\n"})})})]}),"\n",(0,i.jsx)(n.h3,{id:"recursive-instantiation",children:"Recursive instantiation"}),"\n",(0,i.jsx)(n.p,{children:"Let's add a Dataset and a Trainer class. The trainer holds a Dataset and an Optimizer instances."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Additional classes"',children:"class Dataset:\n    name: str\n    path: str\n\n    def __init__(self, name: str, path: str) -> None:\n        self.name = name\n        self.path = path\n\n\nclass Trainer:\n    def __init__(self, optimizer: Optimizer, dataset: Dataset) -> None:\n        self.optimizer = optimizer\n        self.dataset = dataset\n"})}),"\n",(0,i.jsx)(n.p,{children:"With the following config, you can instantiate the whole thing with a single call:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",metastring:'title="Example config"',children:"trainer:\n  _target_: my_app.Trainer\n  optimizer:\n    _target_: my_app.Optimizer\n    algo: SGD\n    lr: 0.01\n  dataset:\n    _target_: my_app.Dataset\n    name: Imagenet\n    path: /datasets/imagenet\n"})}),"\n",(0,i.jsx)(n.p,{children:"Hydra will instantiate nested objects recursively by default."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"trainer = instantiate(cfg.trainer)\nprint(trainer)\n# Trainer(\n#  optimizer=Optimizer(algo=SGD,lr=0.01),\n#  dataset=Dataset(name=Imagenet, path=/datasets/imagenet)\n# )\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can override parameters for nested objects:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'trainer = instantiate(\n    cfg.trainer,\n    optimizer={"lr": 0.3},\n    dataset={"name": "cifar10", "path": "/datasets/cifar10"},\n)\nprint(trainer)\n# Trainer(\n#   optimizer=Optimizer(algo=SGD,lr=0.3),\n#   dataset=Dataset(name=cifar10, path=/datasets/cifar10)\n# )\n'})}),"\n",(0,i.jsx)(n.p,{children:"Similarly, positional arguments of nested objects can be overridden:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'obj = instantiate(\n    cfg.object,\n    # pass 1 and 2 as positional arguments to the target object\n    1, 2,\n    # pass 3 and 4 as positional arguments to a nested child object\n    child={"_args_": [3, 4]},\n)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"disable-recursive-instantiation",children:"Disable recursive instantiation"}),"\n",(0,i.jsxs)(n.p,{children:["You can disable recursive instantiation by setting ",(0,i.jsx)(n.code,{children:"_recursive_"})," to ",(0,i.jsx)(n.code,{children:"False"})," in the config node or in the call-site\nIn that case the Trainer object will receive an OmegaConf DictConfig for nested dataset and optimizer instead of the instantiated objects."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"optimizer = instantiate(cfg.trainer, _recursive_=False)\nprint(optimizer)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"Trainer(\n  optimizer={\n    '_target_': 'my_app.Optimizer', 'algo': 'SGD', 'lr': 0.01\n  },\n  dataset={\n    '_target_': 'my_app.Dataset', 'name': 'Imagenet', 'path': '/datasets/imagenet'\n  }\n)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parameter-conversion-strategies",children:"Parameter conversion strategies"}),"\n",(0,i.jsxs)(n.p,{children:["By default, the parameters passed to the target are either primitives (int,\nfloat, bool etc) or OmegaConf containers (",(0,i.jsx)(n.code,{children:"DictConfig"}),", ",(0,i.jsx)(n.code,{children:"ListConfig"}),").\nOmegaConf containers have many advantages over primitive dicts and lists,\nincluding convenient attribute access for keys,\n",(0,i.jsx)(n.a,{href:"https://omegaconf.readthedocs.io/en/latest/structured_config.html",children:"duck-typing as instances of dataclasses or attrs classes"}),", and\nsupport for ",(0,i.jsx)(n.a,{href:"https://omegaconf.readthedocs.io/en/latest/usage.html#variable-interpolation",children:"variable interpolation"}),"\nand ",(0,i.jsx)(n.a,{href:"https://omegaconf.readthedocs.io/en/latest/custom_resolvers.html",children:"custom resolvers"}),".\nIf the callable targeted by ",(0,i.jsx)(n.code,{children:"instantiate"})," leverages OmegaConf's features, it\nwill make sense to pass ",(0,i.jsx)(n.code,{children:"DictConfig"})," and ",(0,i.jsx)(n.code,{children:"ListConfig"})," instances directly to\nthat callable."]}),"\n",(0,i.jsxs)(n.p,{children:["That being said, in many cases it's desired to pass normal Python dicts and\nlists, rather than ",(0,i.jsx)(n.code,{children:"DictConfig"})," or ",(0,i.jsx)(n.code,{children:"ListConfig"})," instances, as arguments to your\ncallable. You can change instantiate's argument conversion strategy using the\n",(0,i.jsx)(n.code,{children:"_convert_"})," parameter. Supported values are:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"none"'})," : Default behavior, Use OmegaConf containers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"partial"'})," : Convert OmegaConf containers to dict and list, except\nStructured Configs, which remain as DictConfig instances."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"object"'})," : Convert OmegaConf containers to dict and list, except Structured\nConfigs, which are converted to instances of the backing dataclass / attr\nclass using ",(0,i.jsx)(n.code,{children:"OmegaConf.to_object"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"all"'})," : Convert everything to primitive containers"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The conversion strategy applies recursively to all subconfigs of the instantiation target.\nHere is an example demonstrating the various conversion strategies:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from dataclasses import dataclass\nfrom omegaconf import DictConfig, OmegaConf\nfrom hydra.utils import instantiate\n\n@dataclass\nclass Foo:\n    a: int = 123\n\nclass MyTarget:\n    def __init__(self, foo, bar):\n        self.foo = foo\n        self.bar = bar\n\ncfg = OmegaConf.create(\n    {\n        "_target_": "__main__.MyTarget",\n        "foo": Foo(),\n        "bar": {"b": 456},\n    }\n)\n\nobj_none = instantiate(cfg, _convert_="none")\nassert isinstance(obj_none, MyTarget)\nassert isinstance(obj_none.foo, DictConfig)\nassert isinstance(obj_none.bar, DictConfig)\n\nobj_partial = instantiate(cfg, _convert_="partial")\nassert isinstance(obj_partial, MyTarget)\nassert isinstance(obj_partial.foo, DictConfig)\nassert isinstance(obj_partial.bar, dict)\n\nobj_object = instantiate(cfg, _convert_="object")\nassert isinstance(obj_object, MyTarget)\nassert isinstance(obj_object.foo, Foo)\nassert isinstance(obj_object.bar, dict)\n\nobj_all = instantiate(cfg, _convert_="all")\nassert isinstance(obj_all, MyTarget)\nassert isinstance(obj_all.foo, dict)\nassert isinstance(obj_all.bar, dict)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Passing the ",(0,i.jsx)(n.code,{children:"_convert_"})," keyword argument to ",(0,i.jsx)(n.code,{children:"instantiate"})," has the same effect as defining\na ",(0,i.jsx)(n.code,{children:"_convert_"})," attribute on your config object. Here is an example creating\ninstances of ",(0,i.jsx)(n.code,{children:"MyTarget"})," that are equivalent to the above:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'cfg_none = OmegaConf.create({..., "_convert_": "none"})\nobj_none = instantiate(cfg_none)\n\ncfg_partial = OmegaConf.create({..., "_convert_": "partial"})\nobj_partial = instantiate(cfg_partial)\n\ncfg_object = OmegaConf.create({..., "_convert_": "object"})\nobj_object = instantiate(cfg_object)\n\ncfg_all = OmegaConf.create({..., "_convert_": "all"})\nobj_all = instantiate(cfg_all)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"partial-instantiation",children:"Partial Instantiation"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes you may not set all parameters needed to instantiate an object from the configuration, in this case you can set\n",(0,i.jsx)(n.code,{children:"_partial_"})," to be ",(0,i.jsx)(n.code,{children:"True"})," to get a ",(0,i.jsx)(n.code,{children:"functools.partial"})," wrapped object or method, then complete initializing the object in\nthe application code. Here is an example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Example classes"',children:'class Optimizer:\n    algo: str\n    lr: float\n\n    def __init__(self, algo: str, lr: float) -> None:\n        self.algo = algo\n        self.lr = lr\n\n    def __repr__(self) -> str:\n        return f"Optimizer(algo={self.algo},lr={self.lr})"\n\n\nclass Model:\n    def __init__(self, optim_partial: Any, lr: float):\n        super().__init__()\n        self.optim = optim_partial(lr=lr)\n        self.lr = lr\n\n    def __repr__(self) -> str:\n        return f"Model(Optimizer={self.optim},lr={self.lr})"\n'})}),"\n",(0,i.jsxs)("div",{className:"row",children:[(0,i.jsx)("div",{className:"col col--5",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",metastring:'title="Config"',children:"model:\n  _target_: my_app.Model\n  optim_partial:\n    _partial_: true\n    _target_: my_app.Optimizer\n    algo: SGD\n  lr: 0.01\n"})})}),(0,i.jsx)("div",{className:"col col--7",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'title="Instantiation"',children:'model = instantiate(cfg.model)\nprint(model)\n# "Model(Optimizer=Optimizer(algo=SGD,lr=0.01),lr=0.01)\n'})})})]}),"\n",(0,i.jsxs)(n.p,{children:["If you are repeatedly instantiating the same config,\nusing ",(0,i.jsx)(n.code,{children:"_partial_=True"})," may provide a significant speedup as compared with regular (non-partial) instantiation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"factory = instantiate(config, _partial_=True)\nobj = factory()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, repeatedly calling ",(0,i.jsx)(n.code,{children:"factory"})," would be faster than repeatedly calling ",(0,i.jsx)(n.code,{children:"instantiate(config)"}),".\nA caveat of this approach is that the same keyword arguments would be re-used in each call to ",(0,i.jsx)(n.code,{children:"factory"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class Foo:\n    ...\n\nclass Bar:\n    def __init__(self, foo):\n        self.foo = foo\n\nbar_conf = {\n    "_target_": "__main__.Bar",\n    "foo": {"_target_": "__main__.Foo"},\n}\n\nbar_factory = instantiate(bar_conf, _partial_=True)\nbar1 = bar_factory()\nbar2 = bar_factory()\n\nassert bar1 is not bar2\nassert bar1.foo is bar2.foo  # the `Foo` instance is re-used here\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This does not apply if ",(0,i.jsx)(n.code,{children:"_partial_=False"}),",\nin which case a new ",(0,i.jsx)(n.code,{children:"Foo"})," instance would be created with each call to ",(0,i.jsx)(n.code,{children:"instantiate"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"instantiation-of-builtins",children:"Instantiation of builtins"}),"\n",(0,i.jsxs)(n.p,{children:["The value of ",(0,i.jsx)(n.code,{children:"_target_"})," passed to ",(0,i.jsx)(n.code,{children:"instantiate"}),' should be a "dotpath" pointing\nto some callable that can be looked up via a combination of ',(0,i.jsx)(n.code,{children:"import"})," and ",(0,i.jsx)(n.code,{children:"getattr"}),".\nIf you want to target one of Python's ",(0,i.jsx)(n.a,{href:"https://docs.python.org/3/library/functions.html",children:"built-in functions"})," (such as ",(0,i.jsx)(n.code,{children:"len"})," or ",(0,i.jsx)(n.code,{children:"print"})," or ",(0,i.jsx)(n.code,{children:"divmod"}),"),\nyou will need to provide a dotpath looking up that function in Python's ",(0,i.jsx)(n.a,{href:"https://docs.python.org/3/library/builtins.html",children:(0,i.jsx)(n.code,{children:"builtins"})})," module."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from hydra.utils import instantiate\n# instantiate({"_target_": "len"}, [1,2,3])  # this gives an InstantiationException\ninstantiate({"_target_": "builtins.len"}, [1,2,3])  # this works, returns the number 3\n'})}),"\n",(0,i.jsx)(n.h3,{id:"dotpath-lookup-machinery",children:"Dotpath lookup machinery"}),"\n",(0,i.jsxs)(n.p,{children:["Hydra looks up a given ",(0,i.jsx)(n.code,{children:"_target_"})," by attempting to find a module that\ncorresponds to a prefix of the given dotpath and then looking for an object in\nthat module corresponding to the dotpath's tail. For example, to look up a ",(0,i.jsx)(n.code,{children:"_target_"}),"\ngiven by the dotpath ",(0,i.jsx)(n.code,{children:'"my_module.my_nested_module.my_object"'}),", hydra first locates\nthe module ",(0,i.jsx)(n.code,{children:"my_module.my_nested_module"}),", then find ",(0,i.jsx)(n.code,{children:"my_object"})," inside that nested module."]}),"\n",(0,i.jsxs)(n.p,{children:["Hydra exposes an API allowing direct use of this dotpath lookup machinery.\nThe following three functions, which can be imported from the ",(0,i.jsx)(a,{to:"hydra/utils.py",children:"hydra.utils"})," module,\naccept a string-typed dotpath as an argument and return the located class/callable/object:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def get_class(path: str) -> type:\n    """\n    Look up a class based on a dotpath.\n    Fails if the path does not point to a class.\n\n    >>> import my_module\n    >>> from hydra.utils import get_class\n    >>> assert get_class("my_module.MyClass") is my_module.MyClass\n    """\n    ...\n\ndef get_method(path: str) -> Callable[..., Any]:\n    """\n    Look up a callable based on a dotpath.\n    Fails if the path does not point to a callable object.\n\n    >>> import my_module\n    >>> from hydra.utils import get_method\n    >>> assert get_method("my_module.my_function") is my_module.my_function\n    """\n    ...\n\n# Alias for get_method\nget_static_method = get_method\n\ndef get_object(path: str) -> Any:\n    """\n    Look up a callable based on a dotpath.\n\n    >>> import my_module\n    >>> from hydra.utils import get_object\n    >>> assert get_object("my_module.my_object") is my_module.my_object\n    """\n    ...\n'})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}function m(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},49595:(e,n,t)=>{t.d(n,{A:()=>l,C:()=>c});t(96540);var a=t(28774),i=t(44586),s=t(48295),o=t(74848);function r(e){const n=(0,s.ir)();return(0,i.default)().siteConfig.customFields.githubLinkVersionToBaseUrl[n?.name??"current"]+e}function l(e){return(0,o.jsx)(a.default,{...e,to:r(e.to),target:"_blank"})}function c(e){const n=e.text??"Example (Click Here)";return(0,o.jsxs)(l,{...e,children:[(0,o.jsx)("span",{children:"\xa0"}),(0,o.jsx)("img",{src:"https://img.shields.io/badge/-"+n+"-informational",alt:"Example (Click Here)"})]})}}}]);