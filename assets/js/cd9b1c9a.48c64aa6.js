"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7041],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var s=t(96540);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},49595:(e,n,t)=>{t.d(n,{A:()=>r,C:()=>l});t(96540);var s=t(28774),o=t(44586),i=t(48295),a=t(74848);function c(e){const n=(0,i.ir)();return(0,o.default)().siteConfig.customFields.githubLinkVersionToBaseUrl[n?.name??"current"]+e}function r(e){return(0,a.jsx)(s.default,{...e,to:c(e.to),target:"_blank"})}function l(e){const n=e.text??"Example (Click Here)";return(0,a.jsxs)(r,{...e,children:[(0,a.jsx)("span",{children:"\xa0"}),(0,a.jsx)("img",{src:"https://img.shields.io/badge/-"+n+"-informational",alt:"Example (Click Here)"})]})}},65835:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>g,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"tutorials/structured_config/dynamic_schema","title":"Dynamic schema with many configs","description":"In this page we will see how to get runtime type safety for configs with dynamic schema.","source":"@site/versioned_docs/version-1.0/tutorials/structured_config/7_dynamic_schema_many_configs.md","sourceDirName":"tutorials/structured_config","slug":"/tutorials/structured_config/dynamic_schema","permalink":"/docs/1.0/tutorials/structured_config/dynamic_schema","draft":false,"unlisted":false,"editUrl":"https://github.com/facebookresearch/hydra/edit/main/website/versioned_docs/version-1.0/tutorials/structured_config/7_dynamic_schema_many_configs.md","tags":[],"version":"1.0","lastUpdatedBy":"Ryan Soklaski","lastUpdatedAt":1761332619000,"sidebarPosition":7,"frontMatter":{"id":"dynamic_schema","title":"Dynamic schema with many configs"},"sidebar":"docs","previous":{"title":"Static schema with many configs","permalink":"/docs/1.0/tutorials/structured_config/static_schema"},"next":{"title":"Config Store API","permalink":"/docs/1.0/tutorials/structured_config/config_store"}}');var o=t(74848),i=t(28453),a=t(49595);const c={id:"dynamic_schema",title:"Dynamic schema with many configs"},r=void 0,l={},d=[];function h(e){const n={br:"br",code:"code",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(a.C,{to:"examples/tutorials/structured_configs/7_dynamic_schema_many_configs"}),"\n",(0,o.jsxs)(n.p,{children:["In this page we will see how to get runtime type safety for configs with dynamic schema.\nOur top level config contains a single field - ",(0,o.jsx)(n.code,{children:"db"}),", with the type ",(0,o.jsx)(n.code,{children:"DBConfig"}),".\nBased on user choice, we would like its type to be either ",(0,o.jsx)(n.code,{children:"MySQLConfig"})," or ",(0,o.jsx)(n.code,{children:"PostGreSQLConfig"})," at runtime.\nThe two schemas differs: config files that are appropriate for one are inappropriate for the other."]}),"\n",(0,o.jsx)(n.p,{children:"For each of the two schemas, we have two options - one for prod and one for staging:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",metastring:'title="Config directory"',children:"\u251c\u2500\u2500 config.yaml\n\u2514\u2500\u2500 db\n    \u251c\u2500\u2500 mysql_prod.yaml\n    \u251c\u2500\u2500 mysql_staging.yaml\n    \u251c\u2500\u2500 postgresql_prod.yaml\n    \u2514\u2500\u2500 postgresql_staging.yaml\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:'title="my_app.py"',children:'@dataclass\nclass DBConfig:\n    driver: str = MISSING\n    host: str = MISSING\n\n@dataclass\nclass MySQLConfig(DBConfig):\n    driver: str = "mysql"\n    encoding: str = MISSING\n\n@dataclass\nclass PostGreSQLConfig(DBConfig):\n    driver: str = "postgresql"\n    timeout: int = MISSING\n\n@dataclass\nclass Config:\n    db: DBConfig = MISSING\n\ncs = ConfigStore.instance()\ncs.store(group="schema/db", name="mysql", node=MySQLConfig, package="db")\ncs.store(group="schema/db", name="postgresql", node=PostGreSQLConfig, package="db")\ncs.store(name="config", node=Config)\n\n@hydra.main(config_path="conf", config_name="config")\ndef my_app(cfg: Config) -> None:\n    print(OmegaConf.to_yaml(cfg))\n\nif __name__ == "__main__":\n    my_app()\n'})}),"\n",(0,o.jsx)(n.p,{children:"When composing the config, we need to select both the schema and the actual config group option.\nThis is what the defaults list looks like:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",metastring:'title="config.yaml"',children:"defaults:\n  - schema/db: mysql\n  - db: mysql_staging\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Let's dissect the how we store the schemas into the ",(0,o.jsx)(n.code,{children:"ConfigStore"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'cs.store(group="schema/db", name="mysql", node=MySQLConfig, package="db")\n'})}),"\n",(0,o.jsx)(n.p,{children:"There are several notable things here:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["We use the group ",(0,o.jsx)(n.code,{children:"schema/db"})," and not ",(0,o.jsx)(n.code,{children:"db"}),".",(0,o.jsx)(n.br,{}),"\n","Config Groups are mutually exclusive, only one option can be selected from a Config Group. We want to select both the schema and the config.\nStoring all schemas in subgroups of the config group schema is good practice. This also helps in preventing name collisions."]}),"\n",(0,o.jsxs)(n.li,{children:["We need to specify the package to be ",(0,o.jsx)(n.code,{children:"db"}),".\nBy default, the package for configs stored in the ",(0,o.jsx)(n.code,{children:"ConfigStore"})," is ",(0,o.jsx)(n.code,{children:"_group_"}),". We want to schematize ",(0,o.jsx)(n.code,{children:"db"})," and not ",(0,o.jsx)(n.code,{children:"schema.db"})," in the config so we have to override that."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"By default, we get the mysql staging config:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",metastring:'title="$ python my_app.py"',children:"db:\n  driver: mysql\n  host: mysql001.staging\n  encoding: utf-8\n"})}),"\n",(0,o.jsx)(n.p,{children:"We can change both the schema and the config:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",metastring:'title="$ python my_app.py schema/db=postgresql db=postgresql_prod"',children:"db:\n  driver: postgresql\n  host: postgresql01.prod\n  timeout: 10\n"})}),"\n",(0,o.jsx)(n.p,{children:"If we try to use a postgresql config without changing the schema as well we will get an error:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",metastring:'title="$ python my_app.py db=postgresql_prod"',children:"Error merging db=postgresql_prod\nKey 'timeout' not in 'MySQLConfig'\n        full_key: db.timeout\n        reference_type=DBConfig\n        object_type=MySQLConfig\n"})})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);